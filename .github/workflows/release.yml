name: Release on Tag

# 触发条件：当有标签被推送到仓库时触发该工作流。
# 支持任意格式的标签名，例如 `1.0.0` 或 `v1.0.0`。
on:
  push:
    tags:
      - '*'   # 匹配所有标签推送事件

# 权限设置：授予写入 contents 的权限，
# 这样 GITHUB_TOKEN 才能调用 GitHub Releases API 创建发布。
permissions:
  contents: write

# 定义环境变量供后续步骤使用
env:
  GODOT_VERSION: 4.5.1               # 指定使用的 Godot 版本
  EXPORT_NAME: Singleplayer-Autobattler   # 导出项目名称前缀

# 工作流中的任务定义部分
jobs:

  # 构建 Windows 和 Linux 可执行文件的任务，在 Ubuntu 环境中运行
  export-windows-linux:
    name: Build Windows & Linux (for Release)  # 显示名称
    runs-on: ubuntu-latest                     # 使用最新的 Ubuntu 运行器

    steps:
      # 步骤一：检出源码并启用 Git LFS 支持
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      # 步骤二：安装指定版本的 .NET SDK（用于编译 C# 项目）
      - name: Setup .NET (for restore/build)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      # 步骤三：还原 NuGet 包（如果存在解决方案文件）
      - name: Restore NuGet packages
        run: |
          if [ -f "${{ env.EXPORT_NAME }}.sln" ]; then
            dotnet restore "${{ env.EXPORT_NAME }}.sln"
          else
            echo "Solution file not found, skipping dotnet restore"
          fi

      # 步骤四：安装 Godot 引擎及其导出模板
      - name: Setup Godot (includes export templates)
        uses: chickensoft-games/setup-godot@v2
        with:
          version: ${{ env.GODOT_VERSION }}
          include-importer: true
          include-templates: true

      # 步骤五：尝试构建 C# 解决方案（忽略错误）
      - name: Build C# project (if applicable)
        run: |
          godot --headless --build-solutions --quit || echo "Godot build-solutions returned non-zero (ignored)"

      # 步骤六：创建输出目录结构
      - name: Create export dirs
        run: |
          rm -rf build || true
          mkdir -p build/windows
          mkdir -p build/linux

      # 步骤七：导出 Windows 平台可执行程序
      - name: Export Windows Desktop (x86_64)
        run: |
          set -e
          godot --headless --export-release "Windows Desktop" build/windows/${{ env.EXPORT_NAME }}.exe --quit

      # 步骤八：导出 Linux 平台可执行程序
      - name: Export Linux (x86_64)
        run: |
          set -e
          godot --headless --export-release "Linux" build/linux/${{ env.EXPORT_NAME }}.x86_64 --quit

      # 步骤九：上传 Windows 构建产物作为临时工件保存
      - name: Upload Windows artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.EXPORT_NAME }}-windows
          path: build/windows/
          if-no-files-found: error
          retention-days: 30

      # 步骤十：上传 Linux 构建产物作为临时工件保存
      - name: Upload Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.EXPORT_NAME }}-linux
          path: build/linux/
          if-no-files-found: error
          retention-days: 30


  # 构建 macOS 应用程序的任务，在 macOS 环境中运行
  export-macos:
    name: Build macOS (for Release)
    runs-on: macos-latest

    steps:
      # 同上，检出代码并启用 Git LFS
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      # 安装 .NET SDK
      - name: Setup .NET (for restore/build)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      # 还原 NuGet 包（如适用）
      - name: Restore NuGet packages
        run: |
          if [ -f "${{ env.EXPORT_NAME }}.sln" ]; then
            dotnet restore "${{ env.EXPORT_NAME }}.sln"
          else
            echo "Solution file not found, skipping dotnet restore"
          fi

      # 在 macOS 上安装 Godot 及其导出模板
      - name: Setup Godot on macOS (includes export templates)
        uses: chickensoft-games/setup-godot@v2
        with:
          version: ${{ env.GODOT_VERSION }}
          include-importer: true
          include-templates: true

      # 编译 C# 项目（如有需要）
      - name: Build C# project (if applicable)
        run: |
          godot --headless --build-solutions --quit || echo "Godot build-solutions returned non-zero (ignored)"

      # 创建 macOS 输出目录
      - name: Create macOS export dir
        run: mkdir -p build/macos

      # 导出 macOS 应用包
      - name: Export macOS (.app)
        run: |
          set -e
          godot --headless --export-release "macOS" build/macos/${{ env.EXPORT_NAME }}.app --quit

      # 压缩 .app 文件为 zip 格式以便上传
      - name: Zip macOS app
        run: |
          cd build/macos || exit 0
          if [ -d "${{ env.EXPORT_NAME }}.app" ]; then
            zip -r ../${{ env.EXPORT_NAME }}-macOS.zip "${{ env.EXPORT_NAME }}.app"
          else
            echo ".app not found, skipping zip"
          fi

      # 上传压缩后的 macOS 构建产物
      - name: Upload macOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.EXPORT_NAME }}-macOS
          path: build/${{ env.EXPORT_NAME }}-macOS.zip
          if-no-files-found: error
          retention-days: 30


  # 创建 GitHub Release，并将之前构建的所有平台产物附加到此次发布中
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ export-windows-linux, export-macos ]  # 必须等待上述两个构建任务完成

    steps:
      # 再次检出仓库代码（获取最新信息）
      - name: Checkout
        uses: actions/checkout@v4

      # 下载前面两个 job 中上传的所有构建产物
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: build-artifacts

      # 创建一个新的 GitHub Release
      - name: Create Release (via actions/create-release)
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}         # 使用当前触发的标签名
          release_name: Release ${{ github.ref_name }}
          body: Automated release for tag ${{ github.ref_name }}
          draft: false                             # 非草稿状态
          prerelease: false                        # 不标记为预发布
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 授权访问 GitHub API

      # 将下载下来的各平台构建产物分别打包成 zip 文件
      - name: Zip Linux artifact
        run: |
          ART_DIR="build-artifacts/${{ env.EXPORT_NAME }}-linux"
          ZIP_PATH="${ART_DIR}.zip"
          if [ -d "$ART_DIR" ]; then
            echo "Zipping $ART_DIR -> $ZIP_PATH"
            rm -f "$ZIP_PATH"
            (cd "$(dirname "$ART_DIR")" && zip -r "$(basename "$ZIP_PATH")" "$(basename "$ART_DIR")")
          else
            echo "Warning: $ART_DIR not found, skipping"
          fi

      - name: Zip macOS artifact
        run: |
          ART_DIR="build-artifacts/${{ env.EXPORT_NAME }}-macOS"
          ZIP_PATH="${ART_DIR}.zip"
          if [ -d "$ART_DIR" ]; then
            echo "Zipping $ART_DIR -> $ZIP_PATH"
            rm -f "$ZIP_PATH"
            (cd "$(dirname "$ART_DIR")" && zip -r "$(basename "$ZIP_PATH")" "$(basename "$ART_DIR")")
          else
            echo "Warning: $ART_DIR not found, skipping"
          fi

      - name: Zip Windows artifact
        run: |
          ART_DIR="build-artifacts/${{ env.EXPORT_NAME }}-windows"
          ZIP_PATH="${ART_DIR}.zip"
          if [ -d "$ART_DIR" ]; then
            echo "Zipping $ART_DIR -> $ZIP_PATH"
            rm -f "$ZIP_PATH"
            (cd "$(dirname "$ART_DIR")" && zip -r "$(basename "$ZIP_PATH")" "$(basename "$ART_DIR")")
          else
            echo "Warning: $ART_DIR not found, skipping"
          fi

      # 分别上传三个平台的 zip 包至刚刚创建的 Release 页面
      - name: Upload Linux asset to Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: build-artifacts/${{ env.EXPORT_NAME }}-linux.zip
          asset_name: ${{ env.EXPORT_NAME }}-linux.zip
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload macOS asset to Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: build-artifacts/${{ env.EXPORT_NAME }}-macOS.zip
          asset_name: ${{ env.EXPORT_NAME }}-macOS.zip
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Windows asset to Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: build-artifacts/${{ env.EXPORT_NAME }}-windows.zip
          asset_name: ${{ env.EXPORT_NAME }}-windows.zip
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 调试用途：列出已成功上传到 Release 的附件信息
      - name: List uploaded release assets (debug)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          RELEASE_INFO=$(curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${REPO}/releases/tags/${TAG}")
          echo "$RELEASE_INFO" | jq '.assets | map({name: .name, size: .size, url: .browser_download_url})'
